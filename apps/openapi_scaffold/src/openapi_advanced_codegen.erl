%%%-------------------------------------------------------------------
%%% @doc Advanced Multi-Language Code Generation
%%% Generates client libraries in multiple languages with advanced features
%%% like retry logic, circuit breakers, and type safety.
%%% @end
%%%-------------------------------------------------------------------
-module(openapi_advanced_codegen).

-export([
    generate_typescript_client/2,
    generate_python_client/2,
    generate_erlang_client/2,
    generate_go_client/2,
    generate_rust_client/2,
    generate_graphql_schema/1,
    generate_property_tests/2
]).

%%====================================================================
%% API
%%====================================================================

%% @doc Generate TypeScript client with full type safety
generate_typescript_client(OpenAPISpec, Options) ->
    #{
        <<"openapi">> := Version,
        <<"info">> := Info,
        <<"paths">> := Paths,
        <<"components">> := Components
    } = OpenAPISpec,
    
    %% Generate interfaces from schemas
    Interfaces = generate_typescript_interfaces(maps:get(<<"schemas">>, Components, #{})),
    
    %% Generate API client class
    ClientClass = generate_typescript_client_class(Paths, Info, Options),
    
    %% Generate utility functions
    Utils = generate_typescript_utils(),
    
    %% Combine all parts
    Code = [
        "// Generated by OpenAPI Advanced Scaffolder\n",
        "// Version: ", Version, "\n\n",
        "import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\n",
        "import { CircuitBreaker } from './circuit-breaker';\n",
        "import { RetryPolicy } from './retry-policy';\n\n",
        Interfaces, "\n\n",
        Utils, "\n\n",
        ClientClass
    ],
    
    {ok, iolist_to_binary(Code)}.

%% @doc Generate Python client with async support
generate_python_client(OpenAPISpec, Options) ->
    #{
        <<"openapi">> := Version,
        <<"info">> := Info,
        <<"paths">> := Paths,
        <<"components">> := Components
    } = OpenAPISpec,
    
    %% Generate data classes
    DataClasses = generate_python_dataclasses(maps:get(<<"schemas">>, Components, #{})),
    
    %% Generate async client
    AsyncClient = generate_python_async_client(Paths, Info, Options),
    
    %% Generate sync wrapper
    SyncClient = generate_python_sync_client(Paths, Info),
    
    Code = [
        "# Generated by OpenAPI Advanced Scaffolder\n",
        "# Version: ", Version, "\n\n",
        "from dataclasses import dataclass\n",
        "from typing import Optional, List, Dict, Any, Union\n",
        "import asyncio\n",
        "import aiohttp\n",
        "from tenacity import retry, stop_after_attempt, wait_exponential\n\n",
        DataClasses, "\n\n",
        AsyncClient, "\n\n",
        SyncClient
    ],
    
    {ok, iolist_to_binary(Code)}.

%% @doc Generate Erlang client with OTP patterns
generate_erlang_client(OpenAPISpec, Options) ->
    #{
        <<"info">> := #{<<"title">> := Title},
        <<"paths">> := Paths,
        <<"servers">> := Servers
    } = OpenAPISpec,
    
    ModuleName = generate_module_name(Title),
    BaseUrl = extract_base_url(Servers),
    
    %% Generate module header
    Header = generate_erlang_header(ModuleName),
    
    %% Generate API functions
    ApiFunctions = generate_erlang_api_functions(Paths, BaseUrl, Options),
    
    %% Generate gen_server implementation
    GenServer = generate_erlang_gen_server(ModuleName, Options),
    
    %% Generate types
    Types = generate_erlang_types(OpenAPISpec),
    
    Code = [
        Header, "\n\n",
        Types, "\n\n",
        ApiFunctions, "\n\n",
        GenServer
    ],
    
    {ok, iolist_to_binary(Code)}.

%% @doc Generate Go client with context support
generate_go_client(OpenAPISpec, Options) ->
    #{
        <<"info">> := #{<<"title">> := Title},
        <<"paths">> := Paths
    } = OpenAPISpec,
    
    PackageName = generate_go_package_name(Title),
    
    Code = [
        "// Generated by OpenAPI Advanced Scaffolder\n",
        "package ", PackageName, "\n\n",
        "import (\n",
        "    \"context\"\n",
        "    \"encoding/json\"\n",
        "    \"fmt\"\n",
        "    \"net/http\"\n",
        "    \"time\"\n",
        "    \"github.com/sony/gobreaker\"\n",
        ")\n\n",
        generate_go_types(OpenAPISpec),
        "\n\n",
        generate_go_client_struct(Options),
        "\n\n",
        generate_go_methods(Paths)
    ],
    
    {ok, iolist_to_binary(Code)}.

%% @doc Generate Rust client with tokio async runtime
generate_rust_client(OpenAPISpec, Options) ->
    #{
        <<"info">> := #{<<"title">> := Title},
        <<"paths">> := Paths
    } = OpenAPISpec,
    
    ModName = generate_rust_mod_name(Title),
    
    Code = [
        "// Generated by OpenAPI Advanced Scaffolder\n\n",
        "use reqwest::{Client, Error};\n",
        "use serde::{Deserialize, Serialize};\n",
        "use tokio::time::{sleep, Duration};\n",
        "use async_trait::async_trait;\n\n",
        generate_rust_types(OpenAPISpec),
        "\n\n",
        generate_rust_client_impl(Paths, Options)
    ],
    
    {ok, iolist_to_binary(Code)}.

%% @doc Generate GraphQL schema from OpenAPI
generate_graphql_schema(OpenAPISpec) ->
    #{
        <<"paths">> := Paths,
        <<"components">> := Components
    } = OpenAPISpec,
    
    %% Convert OpenAPI schemas to GraphQL types
    Types = convert_schemas_to_graphql(maps:get(<<"schemas">>, Components, #{})),
    
    %% Generate Query type from GET endpoints
    Queries = generate_graphql_queries(Paths),
    
    %% Generate Mutation type from POST/PUT/DELETE endpoints
    Mutations = generate_graphql_mutations(Paths),
    
    Schema = [
        "# Generated GraphQL Schema from OpenAPI\n\n",
        Types, "\n\n",
        "type Query {\n",
        Queries,
        "}\n\n",
        "type Mutation {\n",
        Mutations,
        "}\n"
    ],
    
    {ok, iolist_to_binary(Schema)}.

%% @doc Generate property-based tests using PropEr
generate_property_tests(OpenAPISpec, Options) ->
    #{
        <<"paths">> := Paths,
        <<"components">> := Components
    } = OpenAPISpec,
    
    ModuleName = maps:get(module_name, Options, "api_prop_tests"),
    
    %% Generate property generators for each schema
    Generators = generate_proper_generators(maps:get(<<"schemas">>, Components, #{})),
    
    %% Generate properties for each endpoint
    Properties = generate_endpoint_properties(Paths, Options),
    
    Code = [
        "-module(", ModuleName, ").\n",
        "-include_lib(\"proper/include/proper.hrl\").\n",
        "-compile(export_all).\n\n",
        "%% Generators\n",
        Generators, "\n\n",
        "%% Properties\n",
        Properties
    ],
    
    {ok, iolist_to_binary(Code)}.

%%====================================================================
%% Internal functions - TypeScript Generation
%%====================================================================

generate_typescript_interfaces(Schemas) ->
    Interfaces = maps:fold(fun(Name, Schema, Acc) ->
        Interface = generate_typescript_interface(Name, Schema),
        [Interface, "\n\n" | Acc]
    end, [], Schemas),
    iolist_to_binary(lists:reverse(Interfaces)).

generate_typescript_interface(Name, Schema) ->
    Properties = maps:get(<<"properties">>, Schema, #{}),
    Required = maps:get(<<"required">>, Schema, []),
    
    Props = maps:fold(fun(PropName, PropSchema, Acc) ->
        IsRequired = lists:member(PropName, Required),
        OptionalMark = case IsRequired of true -> ""; false -> "?" end,
        Type = typescript_type(PropSchema),
        [io_lib:format("  ~s~s: ~s;~n", [PropName, OptionalMark, Type]) | Acc]
    end, [], Properties),
    
    [
        "export interface ", binary_to_list(Name), " {\n",
        lists:reverse(Props),
        "}"
    ].

typescript_type(#{<<"type">> := <<"string">>}) -> "string";
typescript_type(#{<<"type">> := <<"integer">>}) -> "number";
typescript_type(#{<<"type">> := <<"number">>}) -> "number";
typescript_type(#{<<"type">> := <<"boolean">>}) -> "boolean";
typescript_type(#{<<"type">> := <<"array">>, <<"items">> := Items}) ->
    io_lib:format("~s[]", [typescript_type(Items)]);
typescript_type(#{<<"type">> := <<"object">>}) -> "Record<string, any>";
typescript_type(#{<<"$ref">> := Ref}) ->
    RefName = lists:last(binary:split(Ref, <<"/">>, [global])),
    binary_to_list(RefName);
typescript_type(_) -> "any".

generate_typescript_client_class(Paths, Info, Options) ->
    ClassName = maps:get(class_name, Options, "APIClient"),
    Methods = generate_typescript_methods(Paths),
    
    [
        "export class ", ClassName, " {\n",
        "  private axios: AxiosInstance;\n",
        "  private circuitBreaker: CircuitBreaker;\n",
        "  private retryPolicy: RetryPolicy;\n\n",
        "  constructor(config: APIClientConfig) {\n",
        "    this.axios = axios.create({\n",
        "      baseURL: config.baseURL,\n",
        "      timeout: config.timeout || 30000,\n",
        "      headers: config.headers || {}\n",
        "    });\n",
        "    this.circuitBreaker = new CircuitBreaker(config.circuitBreakerOptions);\n",
        "    this.retryPolicy = new RetryPolicy(config.retryOptions);\n",
        "    this.setupInterceptors();\n",
        "  }\n\n",
        "  private setupInterceptors(): void {\n",
        "    // Request interceptor for auth, logging, etc.\n",
        "    this.axios.interceptors.request.use(\n",
        "      (config) => {\n",
        "        // Add request ID for tracing\n",
        "        config.headers['X-Request-ID'] = generateRequestId();\n",
        "        return config;\n",
        "      },\n",
        "      (error) => Promise.reject(error)\n",
        "    );\n",
        "  }\n\n",
        Methods,
        "}\n"
    ].

generate_typescript_methods(Paths) ->
    Methods = maps:fold(fun(Path, PathItem, Acc) ->
        maps:fold(fun(Method, Operation, Acc2) when Method =/= <<"parameters">> ->
            MethodCode = generate_typescript_method(Path, Method, Operation),
            [MethodCode, "\n\n" | Acc2]
        end, Acc, PathItem)
    end, [], Paths),
    iolist_to_binary(lists:reverse(Methods)).

generate_typescript_method(Path, Method, Operation) ->
    OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, Method)),
    Parameters = maps:get(<<"parameters">>, Operation, []),
    RequestBody = maps:get(<<"requestBody">>, Operation, undefined),
    
    %% Generate method signature
    MethodName = camel_case(OperationId),
    Params = generate_typescript_params(Parameters, RequestBody),
    
    [
        "  async ", MethodName, "(", Params, "): Promise<APIResponse> {\n",
        "    return this.circuitBreaker.call(async () => {\n",
        "      return this.retryPolicy.execute(async () => {\n",
        "        const response = await this.axios.request({\n",
        "          method: '", string:uppercase(binary_to_list(Method)), "',\n",
        "          url: '", binary_to_list(Path), "',\n",
        "          // Add params, data, etc. based on operation\n",
        "        });\n",
        "        return response.data;\n",
        "      });\n",
        "    });\n",
        "  }"
    ].

generate_typescript_utils() ->
    [
        "// Utility functions\n",
        "function generateRequestId(): string {\n",
        "  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n",
        "}\n\n",
        "interface APIResponse<T = any> {\n",
        "  data: T;\n",
        "  status: number;\n",
        "  headers: Record<string, string>;\n",
        "}\n\n",
        "interface APIClientConfig {\n",
        "  baseURL: string;\n",
        "  timeout?: number;\n",
        "  headers?: Record<string, string>;\n",
        "  circuitBreakerOptions?: CircuitBreakerOptions;\n",
        "  retryOptions?: RetryOptions;\n",
        "}"
    ].

%%====================================================================
%% Internal functions - Python Generation
%%====================================================================

generate_python_dataclasses(Schemas) ->
    Classes = maps:fold(fun(Name, Schema, Acc) ->
        Class = generate_python_dataclass(Name, Schema),
        [Class, "\n\n" | Acc]
    end, [], Schemas),
    iolist_to_binary(lists:reverse(Classes)).

generate_python_dataclass(Name, Schema) ->
    Properties = maps:get(<<"properties">>, Schema, #{}),
    Required = maps:get(<<"required">>, Schema, []),
    
    Fields = maps:fold(fun(PropName, PropSchema, Acc) ->
        IsRequired = lists:member(PropName, Required),
        Type = python_type(PropSchema, IsRequired),
        Default = if IsRequired -> ""; true -> " = None" end,
        [io_lib:format("    ~s: ~s~s~n", [PropName, Type, Default]) | Acc]
    end, [], Properties),
    
    [
        "@dataclass\n",
        "class ", snake_to_pascal(Name), ":\n",
        lists:reverse(Fields)
    ].

python_type(#{<<"type">> := <<"string">>}, _) -> "str";
python_type(#{<<"type">> := <<"integer">>}, _) -> "int";
python_type(#{<<"type">> := <<"number">>}, _) -> "float";
python_type(#{<<"type">> := <<"boolean">>}, _) -> "bool";
python_type(#{<<"type">> := <<"array">>, <<"items">> := Items}, Required) ->
    ItemType = python_type(Items, true),
    case Required of
        true -> io_lib:format("List[~s]", [ItemType]);
        false -> io_lib:format("Optional[List[~s]]", [ItemType])
    end;
python_type(#{<<"$ref">> := Ref}, Required) ->
    RefName = lists:last(binary:split(Ref, <<"/">>, [global])),
    ClassName = snake_to_pascal(RefName),
    case Required of
        true -> ClassName;
        false -> io_lib:format("Optional[~s]", [ClassName])
    end;
python_type(_, Required) ->
    case Required of
        true -> "Any";
        false -> "Optional[Any]"
    end.

generate_python_async_client(Paths, Info, Options) ->
    ClassName = maps:get(class_name, Options, "AsyncAPIClient"),
    Methods = generate_python_async_methods(Paths),
    
    [
        "class ", ClassName, ":\n",
        "    def __init__(self, base_url: str, **kwargs):\n",
        "        self.base_url = base_url.rstrip('/')\n",
        "        self.session_kwargs = kwargs\n",
        "        self._session: Optional[aiohttp.ClientSession] = None\n\n",
        "    async def __aenter__(self):\n",
        "        self._session = aiohttp.ClientSession(**self.session_kwargs)\n",
        "        return self\n\n",
        "    async def __aexit__(self, exc_type, exc_val, exc_tb):\n",
        "        await self._session.close()\n\n",
        "    @property\n",
        "    def session(self) -> aiohttp.ClientSession:\n",
        "        if self._session is None:\n",
        "            raise RuntimeError('Session not initialized. Use async with statement.')\n",
        "        return self._session\n\n",
        Methods
    ].

generate_python_async_methods(Paths) ->
    Methods = maps:fold(fun(Path, PathItem, Acc) ->
        maps:fold(fun(Method, Operation, Acc2) when Method =/= <<"parameters">> ->
            MethodCode = generate_python_async_method(Path, Method, Operation),
            [MethodCode, "\n\n" | Acc2]
        end, Acc, PathItem)
    end, [], Paths),
    iolist_to_binary(lists:reverse(Methods)).

generate_python_async_method(Path, Method, Operation) ->
    OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, Method)),
    MethodName = to_snake_case(OperationId),
    
    [
        "    @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\n",
        "    async def ", MethodName, "(self, **kwargs) -> Dict[str, Any]:\n",
        "        \"\"\"", maps:get(<<"summary">>, Operation, ""), "\"\"\"\n",
        "        url = f\"{self.base_url}", binary_to_list(Path), "\"\n",
        "        async with self.session.", string:lowercase(binary_to_list(Method)),
        "(url, **kwargs) as response:\n",
        "            response.raise_for_status()\n",
        "            return await response.json()\n"
    ].

generate_python_sync_client(Paths, Info) ->
    [
        "class SyncAPIClient:\n",
        "    \"\"\"Synchronous wrapper around AsyncAPIClient\"\"\"\n",
        "    def __init__(self, base_url: str, **kwargs):\n",
        "        self.async_client = AsyncAPIClient(base_url, **kwargs)\n",
        "        self._loop = asyncio.new_event_loop()\n\n",
        "    def __enter__(self):\n",
        "        self._loop.run_until_complete(self.async_client.__aenter__())\n",
        "        return self\n\n",
        "    def __exit__(self, exc_type, exc_val, exc_tb):\n",
        "        self._loop.run_until_complete(self.async_client.__aexit__(exc_type, exc_val, exc_tb))\n",
        "        self._loop.close()\n\n",
        generate_python_sync_method_wrappers(Paths)
    ].

%%====================================================================
%% Internal functions - Erlang Generation
%%====================================================================

generate_erlang_header(ModuleName) ->
    [
        "%%%-------------------------------------------------------------------\n",
        "%%% @doc ", ModuleName, " - Generated OpenAPI Client\n",
        "%%% @end\n",
        "%%%-------------------------------------------------------------------\n",
        "-module(", ModuleName, ").\n",
        "-behaviour(gen_server).\n\n",
        "%% API\n",
        "-export([start_link/1, stop/0]).\n\n",
        "%% gen_server callbacks\n",
        "-export([init/1, handle_call/3, handle_cast/2, handle_info/2,\n",
        "         terminate/2, code_change/3]).\n\n",
        "-record(state, {\n",
        "    base_url :: string(),\n",
        "    headers :: [{string(), string()}],\n",
        "    circuit_breaker :: pid(),\n",
        "    retry_policy :: map(),\n",
        "    metrics :: pid()\n",
        "}).\n"
    ].

generate_erlang_api_functions(Paths, BaseUrl, Options) ->
    Functions = maps:fold(fun(Path, PathItem, Acc) ->
        maps:fold(fun(Method, Operation, Acc2) when Method =/= <<"parameters">> ->
            Function = generate_erlang_api_function(Path, Method, Operation),
            [Function, "\n\n" | Acc2]
        end, Acc, PathItem)
    end, [], Paths),
    iolist_to_binary(lists:reverse(Functions)).

generate_erlang_api_function(Path, Method, Operation) ->
    OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, Method)),
    FunctionName = to_snake_case(OperationId),
    
    [
        "%% @doc ", maps:get(<<"summary">>, Operation, ""), "\n",
        FunctionName, "(Params) ->\n",
        "    gen_server:call(?MODULE, {", FunctionName, ", Params}).\n"
    ].

generate_erlang_gen_server(ModuleName, Options) ->
    [
        "%%====================================================================\n",
        "%% gen_server callbacks\n",
        "%%====================================================================\n\n",
        "init([Config]) ->\n",
        "    process_flag(trap_exit, true),\n",
        "    BaseUrl = maps:get(base_url, Config),\n",
        "    Headers = maps:get(headers, Config, []),\n",
        "    \n",
        "    %% Initialize circuit breaker\n",
        "    {ok, CircuitBreaker} = circuit_breaker:start_link([\n",
        "        {failure_threshold, 5},\n",
        "        {success_threshold, 2},\n",
        "        {timeout, 30000}\n",
        "    ]),\n",
        "    \n",
        "    %% Initialize metrics\n",
        "    {ok, Metrics} = openapi_metrics:start_link(", ModuleName, "),\n",
        "    \n",
        "    State = #state{\n",
        "        base_url = BaseUrl,\n",
        "        headers = Headers,\n",
        "        circuit_breaker = CircuitBreaker,\n",
        "        retry_policy = #{\n",
        "            max_attempts => 3,\n",
        "            initial_delay => 1000,\n",
        "            max_delay => 10000,\n",
        "            multiplier => 2\n",
        "        },\n",
        "        metrics = Metrics\n",
        "    },\n",
        "    {ok, State}.\n\n",
        "handle_call({Operation, Params}, From, State) ->\n",
        "    %% Execute with circuit breaker and retry logic\n",
        "    spawn_link(fun() ->\n",
        "        Result = execute_with_resilience(Operation, Params, State),\n",
        "        gen_server:reply(From, Result)\n",
        "    end),\n",
        "    {noreply, State}.\n"
    ].

generate_erlang_types(OpenAPISpec) ->
    Schemas = maps:get(<<"schemas">>, maps:get(<<"components">>, OpenAPISpec, #{}), #{}),
    Types = maps:fold(fun(Name, Schema, Acc) ->
        Type = generate_erlang_type(Name, Schema),
        [Type, "\n" | Acc]
    end, [], Schemas),
    [
        "%% Types\n",
        lists:reverse(Types)
    ].

%%====================================================================
%% Internal functions - Utility
%%====================================================================

generate_module_name(Title) when is_binary(Title) ->
    Words = binary:split(Title, [<<" ">>, <<"-">>, <<"_">>], [global]),
    ModuleName = string:join([string:lowercase(binary_to_list(W)) || W <- Words], "_"),
    ModuleName ++ "_client".

extract_base_url([#{<<"url">> := Url} | _]) -> binary_to_list(Url);
extract_base_url([]) -> "http://localhost:8080".

generate_operation_id(Path, Method) ->
    PathParts = [P || P <- binary:split(Path, <<"/">>, [global]), P =/= <<>>],
    MethodStr = binary_to_list(Method),
    PathStr = string:join([binary_to_list(P) || P <- PathParts], "_"),
    iolist_to_binary([MethodStr, "_", PathStr]).

camel_case(Binary) when is_binary(Binary) ->
    camel_case(binary_to_list(Binary));
camel_case(String) ->
    Words = string:tokens(String, "_- "),
    case Words of
        [] -> "";
        [First | Rest] ->
            LowerFirst = string:lowercase(First),
            CapitalizedRest = [capitalize(W) || W <- Rest],
            string:join([LowerFirst | CapitalizedRest], "")
    end.

to_snake_case(Binary) when is_binary(Binary) ->
    to_snake_case(binary_to_list(Binary));
to_snake_case(String) ->
    string:lowercase(string:join(string:tokens(String, "- "), "_")).

capitalize([H|T]) -> [string:to_upper(H) | T];
capitalize([]) -> [].

snake_to_pascal(Binary) when is_binary(Binary) ->
    snake_to_pascal(binary_to_list(Binary));
snake_to_pascal(String) ->
    Words = string:tokens(String, "_"),
    string:join([capitalize(W) || W <- Words], "").

generate_go_package_name(Title) ->
    Words = binary:split(Title, [<<" ">>, <<"-">>, <<"_">>], [global]),
    string:lowercase(binary_to_list(lists:last(Words))).

generate_rust_mod_name(Title) ->
    to_snake_case(Title).

%%====================================================================
%% Internal functions - GraphQL Conversion
%%====================================================================

convert_schemas_to_graphql(Schemas) ->
    Types = maps:fold(fun(Name, Schema, Acc) ->
        Type = convert_schema_to_graphql_type(Name, Schema),
        [Type, "\n\n" | Acc]
    end, [], Schemas),
    iolist_to_binary(lists:reverse(Types)).

convert_schema_to_graphql_type(Name, Schema) ->
    Properties = maps:get(<<"properties">>, Schema, #{}),
    Required = maps:get(<<"required">>, Schema, []),
    
    Fields = maps:fold(fun(PropName, PropSchema, Acc) ->
        IsRequired = lists:member(PropName, Required),
        Type = graphql_type(PropSchema),
        RequiredMark = case IsRequired of true -> "!"; false -> "" end,
        [io_lib:format("  ~s: ~s~s~n", [PropName, Type, RequiredMark]) | Acc]
    end, [], Properties),
    
    [
        "type ", binary_to_list(Name), " {\n",
        lists:reverse(Fields),
        "}"
    ].

graphql_type(#{<<"type">> := <<"string">>}) -> "String";
graphql_type(#{<<"type">> := <<"integer">>}) -> "Int";
graphql_type(#{<<"type">> := <<"number">>}) -> "Float";
graphql_type(#{<<"type">> := <<"boolean">>}) -> "Boolean";
graphql_type(#{<<"type">> := <<"array">>, <<"items">> := Items}) ->
    io_lib:format("[~s]", [graphql_type(Items)]);
graphql_type(#{<<"$ref">> := Ref}) ->
    RefName = lists:last(binary:split(Ref, <<"/">>, [global])),
    binary_to_list(RefName);
graphql_type(_) -> "String".

generate_graphql_queries(Paths) ->
    Queries = maps:fold(fun(Path, PathItem, Acc) ->
        case maps:get(<<"get">>, PathItem, undefined) of
            undefined -> Acc;
            Operation ->
                Query = generate_graphql_query(Path, Operation),
                [Query, "\n" | Acc]
        end
    end, [], Paths),
    iolist_to_binary(lists:reverse(Queries)).

generate_graphql_query(Path, Operation) ->
    OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, <<"get">>)),
    QueryName = camel_case(OperationId),
    ReturnType = determine_graphql_return_type(Operation),
    
    io_lib:format("  ~s: ~s", [QueryName, ReturnType]).

generate_graphql_mutations(Paths) ->
    Mutations = maps:fold(fun(Path, PathItem, Acc) ->
        Methods = [<<"post">>, <<"put">>, <<"patch">>, <<"delete">>],
        lists:foldl(fun(Method, Acc2) ->
            case maps:get(Method, PathItem, undefined) of
                undefined -> Acc2;
                Operation ->
                    Mutation = generate_graphql_mutation(Path, Method, Operation),
                    [Mutation, "\n" | Acc2]
            end
        end, Acc, Methods)
    end, [], Paths),
    iolist_to_binary(lists:reverse(Mutations)).

generate_graphql_mutation(Path, Method, Operation) ->
    OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, Method)),
    MutationName = camel_case(OperationId),
    InputType = determine_graphql_input_type(Operation),
    ReturnType = determine_graphql_return_type(Operation),
    
    io_lib:format("  ~s(input: ~s): ~s", [MutationName, InputType, ReturnType]).

determine_graphql_return_type(Operation) ->
    case maps:get(<<"responses">>, Operation, #{}) of
        #{<<"200">> := #{<<"content">> := Content}} ->
            case maps:get(<<"application/json">>, Content, undefined) of
                #{<<"schema">> := Schema} -> schema_to_graphql_type(Schema);
                _ -> "String"
            end;
        _ -> "String"
    end.

determine_graphql_input_type(Operation) ->
    case maps:get(<<"requestBody">>, Operation, undefined) of
        #{<<"content">> := #{<<"application/json">> := #{<<"schema">> := Schema}}} ->
            schema_to_graphql_type(Schema);
        _ -> "String"
    end.

schema_to_graphql_type(#{<<"$ref">> := Ref}) ->
    RefName = lists:last(binary:split(Ref, <<"/">>, [global])),
    binary_to_list(RefName);
schema_to_graphql_type(#{<<"type">> := <<"array">>, <<"items">> := Items}) ->
    io_lib:format("[~s]", [schema_to_graphql_type(Items)]);
schema_to_graphql_type(_) -> "String".

%%====================================================================
%% Internal functions - PropEr Test Generation
%%====================================================================

generate_proper_generators(Schemas) ->
    Generators = maps:fold(fun(Name, Schema, Acc) ->
        Gen = generate_proper_generator(Name, Schema),
        [Gen, "\n\n" | Acc]
    end, [], Schemas),
    iolist_to_binary(lists:reverse(Generators)).

generate_proper_generator(Name, Schema) ->
    GenName = io_lib:format("gen_~s", [to_snake_case(Name)]),
    Properties = maps:get(<<"properties">>, Schema, #{}),
    
    PropGens = maps:fold(fun(PropName, PropSchema, Acc) ->
        PropGen = generate_property_generator(PropName, PropSchema),
        [{PropName, PropGen} | Acc]
    end, [], Properties),
    
    [
        GenName, "() ->\n",
        "    ?LET(Props, \n",
        "         {", string:join([io_lib:format("~s", [Gen]) || {_, Gen} <- PropGens], ",\n          "), "},\n",
        "         #{\n",
        string:join([io_lib:format("           <<\"~s\">> => element(~p, Props)", [Name, N]) 
                     || {N, {Name, _}} <- lists:enumerate(PropGens)], ",\n"),
        "\n         }).\n"
    ].

generate_property_generator(_Name, #{<<"type">> := <<"string">>}) ->
    "?SUCHTHAT(S, string(), length(S) > 0)";
generate_property_generator(_Name, #{<<"type">> := <<"integer">>}) ->
    "integer()";
generate_property_generator(_Name, #{<<"type">> := <<"number">>}) ->
    "float()";
generate_property_generator(_Name, #{<<"type">> := <<"boolean">>}) ->
    "boolean()";
generate_property_generator(_Name, #{<<"type">> := <<"array">>, <<"items">> := Items}) ->
    ItemGen = generate_property_generator("item", Items),
    io_lib:format("list(~s)", [ItemGen]);
generate_property_generator(_Name, _) ->
    "any()".

generate_endpoint_properties(Paths, Options) ->
    Properties = maps:fold(fun(Path, PathItem, Acc) ->
        maps:fold(fun(Method, Operation, Acc2) when Method =/= <<"parameters">> ->
            Prop = generate_endpoint_property(Path, Method, Operation, Options),
            [Prop, "\n\n" | Acc2]
        end, Acc, PathItem)
    end, [], Paths),
    iolist_to_binary(lists:reverse(Properties)).

generate_endpoint_property(Path, Method, Operation, Options) ->
    OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, Method)),
    PropName = io_lib:format("prop_~s", [to_snake_case(OperationId)]),
    
    [
        PropName, "() ->\n",
        "    ?FORALL(Input, gen_input_", to_snake_case(OperationId), "(),\n",
        "            begin\n",
        "                Result = api_client:", to_snake_case(OperationId), "(Input),\n",
        "                case Result of\n",
        "                    {ok, _Response} -> true;\n",
        "                    {error, Reason} -> \n",
        "                        io:format(\"API call failed: ~p~n\", [Reason]),\n",
        "                        false\n",
        "                end\n",
        "            end).\n"
    ].

generate_typescript_params(Parameters, RequestBody) ->
    ParamList = lists:map(fun(Param) ->
        ParamName = maps:get(<<"name">>, Param),
        Required = maps:get(<<"required">>, Param, false),
        Schema = maps:get(<<"schema">>, Param, #{}),
        Type = typescript_type(Schema),
        OptionalMark = case Required of true -> ""; false -> "?" end,
        io_lib:format("~s~s: ~s", [ParamName, OptionalMark, Type])
    end, Parameters),
    
    BodyParam = case RequestBody of
        undefined -> [];
        _ -> ["body: any"]  % Simplified, should extract actual type
    end,
    
    AllParams = ParamList ++ BodyParam,
    string:join(AllParams, ", ").

generate_python_sync_method_wrappers(Paths) ->
    Methods = maps:fold(fun(Path, PathItem, Acc) ->
        maps:fold(fun(Method, Operation, Acc2) when Method =/= <<"parameters">> ->
            OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, Method)),
            MethodName = to_snake_case(OperationId),
            Wrapper = io_lib:format(
                "    def ~s(self, **kwargs):\n"
                "        return self._loop.run_until_complete(self.async_client.~s(**kwargs))\n\n",
                [MethodName, MethodName]
            ),
            [Wrapper | Acc2]
        end, Acc, PathItem)
    end, [], Paths),
    iolist_to_binary(lists:reverse(Methods)).

generate_go_types(OpenAPISpec) ->
    Schemas = maps:get(<<"schemas">>, maps:get(<<"components">>, OpenAPISpec, #{}), #{}),
    Types = maps:fold(fun(Name, Schema, Acc) ->
        Type = generate_go_type(Name, Schema),
        [Type, "\n\n" | Acc]
    end, [], Schemas),
    iolist_to_binary(lists:reverse(Types)).

generate_go_type(Name, Schema) ->
    Properties = maps:get(<<"properties">>, Schema, #{}),
    Fields = maps:fold(fun(PropName, PropSchema, Acc) ->
        GoType = go_type(PropSchema),
        FieldName = capitalize(binary_to_list(PropName)),
        JsonTag = io_lib:format(" `json:\"~s\"`", [PropName]),
        [io_lib:format("    ~s ~s~s\n", [FieldName, GoType, JsonTag]) | Acc]
    end, [], Properties),
    
    [
        "type ", capitalize(binary_to_list(Name)), " struct {\n",
        lists:reverse(Fields),
        "}"
    ].

go_type(#{<<"type">> := <<"string">>}) -> "string";
go_type(#{<<"type">> := <<"integer">>}) -> "int64";
go_type(#{<<"type">> := <<"number">>}) -> "float64";
go_type(#{<<"type">> := <<"boolean">>}) -> "bool";
go_type(#{<<"type">> := <<"array">>, <<"items">> := Items}) ->
    io_lib:format("[]~s", [go_type(Items)]);
go_type(#{<<"$ref">> := Ref}) ->
    RefName = lists:last(binary:split(Ref, <<"/">>, [global])),
    capitalize(binary_to_list(RefName));
go_type(_) -> "interface{}".

generate_go_client_struct(Options) ->
    [
        "type Client struct {\n",
        "    BaseURL    string\n",
        "    HTTPClient *http.Client\n",
        "    CircuitBreaker *gobreaker.CircuitBreaker\n",
        "}\n\n",
        "func NewClient(baseURL string) *Client {\n",
        "    cb := gobreaker.NewCircuitBreaker(gobreaker.Settings{\n",
        "        Name:        \"API\",\n",
        "        MaxRequests: 3,\n",
        "        Interval:    10 * time.Second,\n",
        "        Timeout:     30 * time.Second,\n",
        "    })\n",
        "    return &Client{\n",
        "        BaseURL: baseURL,\n",
        "        HTTPClient: &http.Client{\n",
        "            Timeout: 30 * time.Second,\n",
        "        },\n",
        "        CircuitBreaker: cb,\n",
        "    }\n",
        "}"
    ].

generate_go_methods(Paths) ->
    Methods = maps:fold(fun(Path, PathItem, Acc) ->
        maps:fold(fun(Method, Operation, Acc2) when Method =/= <<"parameters">> ->
            MethodCode = generate_go_method(Path, Method, Operation),
            [MethodCode, "\n\n" | Acc2]
        end, Acc, PathItem)
    end, [], Paths),
    iolist_to_binary(lists:reverse(Methods)).

generate_go_method(Path, Method, Operation) ->
    OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, Method)),
    MethodName = capitalize(binary_to_list(OperationId)),
    
    [
        "func (c *Client) ", MethodName, "(ctx context.Context) error {\n",
        "    _, err := c.CircuitBreaker.Execute(func() (interface{}, error) {\n",
        "        req, err := http.NewRequestWithContext(ctx, \"", 
        string:uppercase(binary_to_list(Method)), "\", ",
        "c.BaseURL+\"", binary_to_list(Path), "\", nil)\n",
        "        if err != nil {\n",
        "            return nil, err\n",
        "        }\n",
        "        resp, err := c.HTTPClient.Do(req)\n",
        "        if err != nil {\n",
        "            return nil, err\n",
        "        }\n",
        "        defer resp.Body.Close()\n",
        "        return resp, nil\n",
        "    })\n",
        "    return err\n",
        "}"
    ].

generate_rust_types(OpenAPISpec) ->
    Schemas = maps:get(<<"schemas">>, maps:get(<<"components">>, OpenAPISpec, #{}), #{}),
    Types = maps:fold(fun(Name, Schema, Acc) ->
        Type = generate_rust_type(Name, Schema),
        [Type, "\n\n" | Acc]
    end, [], Schemas),
    iolist_to_binary(lists:reverse(Types)).

generate_rust_type(Name, Schema) ->
    Properties = maps:get(<<"properties">>, Schema, #{}),
    Required = maps:get(<<"required">>, Schema, []),
    
    Fields = maps:fold(fun(PropName, PropSchema, Acc) ->
        IsRequired = lists:member(PropName, Required),
        RustType = rust_type(PropSchema, IsRequired),
        FieldName = to_snake_case(PropName),
        [io_lib:format("    pub ~s: ~s,\n", [FieldName, RustType]) | Acc]
    end, [], Properties),
    
    [
        "#[derive(Debug, Clone, Serialize, Deserialize)]\n",
        "pub struct ", snake_to_pascal(Name), " {\n",
        lists:reverse(Fields),
        "}"
    ].

rust_type(#{<<"type">> := <<"string">>}, _) -> "String";
rust_type(#{<<"type">> := <<"integer">>}, _) -> "i64";
rust_type(#{<<"type">> := <<"number">>}, _) -> "f64";
rust_type(#{<<"type">> := <<"boolean">>}, _) -> "bool";
rust_type(#{<<"type">> := <<"array">>, <<"items">> := Items}, _) ->
    ItemType = rust_type(Items, true),
    io_lib:format("Vec<~s>", [ItemType]);
rust_type(#{<<"$ref">> := Ref}, Required) ->
    RefName = lists:last(binary:split(Ref, <<"/">>, [global])),
    TypeName = snake_to_pascal(RefName),
    case Required of
        true -> TypeName;
        false -> io_lib:format("Option<~s>", [TypeName])
    end;
rust_type(_, Required) ->
    case Required of
        true -> "serde_json::Value";
        false -> "Option<serde_json::Value>"
    end.

generate_rust_client_impl(Paths, Options) ->
    [
        "pub struct ApiClient {\n",
        "    client: Client,\n",
        "    base_url: String,\n",
        "}\n\n",
        "impl ApiClient {\n",
        "    pub fn new(base_url: String) -> Self {\n",
        "        Self {\n",
        "            client: Client::builder()\n",
        "                .timeout(Duration::from_secs(30))\n",
        "                .build()\n",
        "                .expect(\"Failed to create HTTP client\"),\n",
        "            base_url,\n",
        "        }\n",
        "    }\n\n",
        generate_rust_methods(Paths),
        "}"
    ].

generate_rust_methods(Paths) ->
    Methods = maps:fold(fun(Path, PathItem, Acc) ->
        maps:fold(fun(Method, Operation, Acc2) when Method =/= <<"parameters">> ->
            MethodCode = generate_rust_method(Path, Method, Operation),
            [MethodCode, "\n\n" | Acc2]
        end, Acc, PathItem)
    end, [], Paths),
    iolist_to_binary(lists:reverse(Methods)).

generate_rust_method(Path, Method, Operation) ->
    OperationId = maps:get(<<"operationId">>, Operation, generate_operation_id(Path, Method)),
    MethodName = to_snake_case(OperationId),
    
    [
        "    pub async fn ", MethodName, "(&self) -> Result<serde_json::Value, Error> {\n",
        "        let url = format!(\"{}{}\", self.base_url, \"", binary_to_list(Path), "\");\n",
        "        let response = self.client\n",
        "            .", string:lowercase(binary_to_list(Method)), "(&url)\n",
        "            .send()\n",
        "            .await?;\n",
        "        \n",
        "        if response.status().is_success() {\n",
        "            Ok(response.json().await?)\n",
        "        } else {\n",
        "            Err(Error::from(response.status()))\n",
        "        }\n",
        "    }"
    ].

generate_erlang_type(Name, Schema) ->
    Properties = maps:get(<<"properties">>, Schema, #{}),
    Fields = maps:fold(fun(PropName, _PropSchema, Acc) ->
        FieldName = binary_to_atom(PropName, utf8),
        [io_lib:format("    ~p :: term()", [FieldName]) | Acc]
    end, [], Properties),
    
    RecordName = to_snake_case(Name),
    [
        "-record(", RecordName, ", {\n",
        string:join(lists:reverse(Fields), ",\n"),
        "\n})."
    ].